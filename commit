#!/usr/bin/env python3

import yaml
from pyroute2 import NDB, IPRoute
import argparse

parser = argparse.ArgumentParser(description="Configure ONL device interfaces and routing")
parser.add_argument("--config", type=str, help="Configuration file to load", default="config.yml")
args = parser.parse_args()

ndb = NDB()

with open(args.config, "r") as f:
    config = yaml.load(f, Loader=yaml.Loader)

# configure LACP bundles
# parse the interface configuration for such bundles,
# assembling a data structure to describe them:
# lacp_config = [
#   {"name": "bond1", "members": ["swp1", "swp2"]}
# ]
lacp_config = {}
for interface in config["interfaces"]:
    if "lacp" in interface:
        if interface["lacp"] in lacp_config:
            lacp_config[interface["lacp"]].append(interface["name"])
        else:
            lacp_config[interface["lacp"]] = [interface["name"]]
lacp_config = [{"name": name, "members": lacp_config[name]} for name in lacp_config.keys()]

# retrieve all existing LACP bundles
current_bundles = set(map(
    lambda x: x["ifname"],
    ndb.interfaces
        .dump()
        .filter(lambda x: x.kind == "bond")
        .select("ifname")
))

# get the declared bundles
declared_bundles = set(map(
    lambda x: x["name"], 
    lacp_config
))

# remove all the bundles that shouldn't exist anymore
for bundle in (current_bundles - declared_bundles):
    (ndb
        .interfaces[bundle]
        .remove()
        .commit()
    )
    print(f"Removed existing LACP bundle {bundle} that is no longer present in configuration")

# create all the new bundles that don't exist yet
for bundle in (declared_bundles - current_bundles):
    (ndb
        .interfaces
        .create(
            ifname=bundle,
            kind="bond",
            bond_mode=4, # LACP
            bond_ad_lacp_rate=1, # LACP rate fast
        )
        .commit()
    )
    print(f"Created new LACP bundle {bundle}")

# now process all the member interfaces
lacp_members = set()
for bundle in lacp_config:
    # grab the index for easy reference
    master_idx = ndb.interfaces[bundle["name"]]["index"]

    # remember all bundle members so they can be skipped in  
    # future layer 2 or 3 interface configurations
    lacp_members.update(bundle["members"])

    # grab all interfaces currently part of this bundle
    current_members = set(map(
        lambda x: x["ifname"], 
        ndb.interfaces
            .dump()
            .filter(lambda x: x.master == master_idx)
            .select("ifname")
        ))

    # turn the names of members supposed to be in the budle into a set
    declared_members = set(bundle["members"])

    # remove all the members that shouldn't be in the bundle anymore
    for member in (current_members - declared_members):
        (ndb
            .interfaces[bundle["name"]]
            .del_port(member)
            .commit()
        )
        print(f"Deleted member {member} from bundle {bundle['name']}")

    # add all the members that should be in the bundle but aren't yet
    members_to_add = declared_members - current_members
    if len(members_to_add):
        # however, doing so requires the bundle itself to have no master interface set
        # this will briefly interrupt traffic as it'll have to be reset
        upstream_master = ndb.interfaces[bundle["name"]]["master"]
        if upstream_master:
            (ndb
                .interfaces[upstream_master]
                .del_port(bundle["name"])
                .commit()
            )
            print(f"Temporarily removed bundle {bundle['name']} from its upstream")
        # now add all the members
        for member in members_to_add:
            # for this, the new member has to be down
            previous_state = ndb.interfaces[member]["state"]
            if previous_state != "down":
                (ndb
                    .interfaces[member]
                    .set("state", "down")
                    .commit()
                )
            # add it to the bundle
            (ndb
                .interfaces[bundle["name"]]
                .add_port(member)
                .commit()
            )
            # restore the previous state if it wasn't down
            if previous_state != "down":
                (ndb
                    .interfaces[member]
                    .set("state", previous_state)
                    .commit()
                )
            print(f"Added member {member} to bundle {bundle['name']}")
        # and restore the upstream master if needed
        if upstream_master:
            (ndb
                .interfaces[upstream_master]
                .add_port(bundle["name"])
                .commit()
            )
            print(f"Restored upstream for bundle {bundle['name']}")

# create all the virtual switches
# include a default one in case none are defined
virtual_switches = set(["default-switch"])
for interface in config["interfaces"]:
    if "virtual_switch" in interface:
        virtual_switches.add(interface["virtual_switch"])

for virtual_switch in virtual_switches:        
    if virtual_switch not in ndb.interfaces:
        (ndb
            .interfaces
            .create(
                ifname=virtual_switch,
                kind="bridge",
                br_vlan_filtering=1,
                br_vlan_default_pvid=1,
                br_vlan_stats_enabled=1,
            )
            .commit()
        )
        print(f"Created VLAN capable switch {virtual_switch}")

# helper function to retrieve NTLM attributes of a certain kind
# from the large list of attributes an interface might have
def _get_attribute(search_key, attrs):
    result = []
    for (key, value) in attrs:
        if search_key == key:
            result.append(value)
    return result

# function to retrieve the current VLANs on an interface
def get_vlans(ifname):
    vlans = []
    for interface in ipr.get_vlans():
        candidate_name = _get_attribute("IFLA_IFNAME", interface["attrs"])[0]
        if candidate_name == ifname:
            spec = _get_attribute("IFLA_AF_SPEC", interface["attrs"])[0]
            vlans = _get_attribute("IFLA_BRIDGE_VLAN_INFO", spec["attrs"])
    return list(map(lambda x: {"flags": x["flags"], "vid": x["vid"]}, vlans))

# parse the VLANs into a data structure where VIDs can be looked up by name
vlans = {x["name"]: x["id"] for x in config["vlans"]}

# configure the switchports
# NDB does not support VLAN filters at this time, so that step
# has to be performed via the IPRoute interface instead
ipr = IPRoute()

for interface in config["interfaces"]:
    # force skipping LACP members
    if interface["name"] in lacp_members:
        continue

    # get the interface index for easy access in later operations
    interface_idx = ndb.interfaces[interface["name"]]["index"]

    # check if the interface is a layer 2 port
    if "l3" not in interface:
        # it is, add it to the appropriate bridge if needed
        bridge_name = interface["virtual_switch"] if "virtual_switch" in interface else "default-switch"
        bridge_idx = ndb.interfaces[bridge_name]["index"]
        if ndb.interfaces[interface["name"]]["master"] != bridge_idx:
            (ndb
                .interfaces[bridge_name]
                .add_port(interface["name"])
                .commit()
            )
            print(f"Added interface {interface['name']} to bridge {bridge_name}")
        
        # process tagged and untagged VLANs. tagged has a flag of 0, untagged is 6
        # to this in a loop since all the other code is duplicated
        # if a voice VLAN is set, and it to the tagged list if it isn't in there yet
        tagged_vlans = interface["tagged_vlans"] if "tagged_vlans" in interface else []
        if "voice_vlan" in interface:
            if interface["voice_vlan"] not in tagged_vlans:
                tagged_vlans.append(interface["voice_vlan"])

        # retrieve the current untagged and tagged VLANs for the interface
        current_vlans = get_vlans(interface["name"])
        # turn them into a set of tuples so they can be used in sets
        current_vlans = list(map(lambda x: (x["flags"], x["vid"]), current_vlans))

        for mode in [(6, "untagged_vlan"), (0, "tagged_vlans")]:
            description = mode[1].replace("_vlans", "").replace("_vlan", "")
            # fetch what is currenly in place
            current = set(filter(lambda x: x[0] == mode[0], current_vlans))
            if mode[1] in interface:
                if mode[1] == "untagged_vlan":
                    declared = set([(6, vlans[interface["untagged_vlan"]])])
                else:
                    declared = set([(0, vlans[x]) for x in tagged_vlans])
                declared = set(declared)
            else:
                declared = set()
            # remove any unneeded configuration
            for vlan_info in (current - declared):
                ipr.vlan_filter(
                    "del",
                    index=interface_idx,
                    vlan_info={"flags": vlan_info[0], "vid": vlan_info[1]},
                )
                print(f"Removed {description} VLAN {vlan_info[1]} from interface {interface['name']}")
            # and add the new one
            for vlan_info in (declared - current):
                ipr.vlan_filter(
                    "add",
                    index=interface_idx,
                    vlan_info={"flags": vlan_info[0], "vid": vlan_info[1]},
                )
                print(f"Added {description} VLAN {vlan_info[1]} to interface {interface['name']}")

    # configure the up/down state
    # default to down if not specified
    state = "up" if "enabled" in interface and interface["enabled"] else "down"
    if ndb.interfaces[interface["name"]]["state"] != state:
        (ndb
            .interfaces[interface["name"]]
            .set("state", state)
            .commit()
        )
        print(f"Set interface {interface['name']} state to {state}")

ndb.close()