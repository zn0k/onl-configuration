#!/usr/bin/env python3

import yaml
from pyroute2 import NDB, IPRoute
import argparse

parser = argparse.ArgumentParser(description="Configure ONL device interfaces and routing")
parser.add_argument("--config", type=str, help="Configuration file to load", default="config.yml")
args = parser.parse_args()

ndb = NDB()

with open(args.config, "r") as f:
    config = yaml.load(f, Loader=yaml.Loader)

# configure LACP bundles
# parse the interface configuration for such bundles,
# assembling a data structure to describe them:
# lacp_config = [
#   {"name": "bond1", "members": ["swp1", "swp2"]}
# ]
lacp_config = {}
for interface in config["interfaces"]:
    if "lacp" in interface:
        if interface["lacp"] in lacp_config:
            lacp_config[interface["lacp"]].append(interface["name"])
        else:
            lacp_config[interface["lacp"]] = [interface["name"]]
lacp_config = [{"name": name, "members": lacp_config[name]} for name in lacp_config.keys()]

# retrieve all existing LACP bundles
current_bundles = set(map(
    lambda x: x["ifname"],
    ndb.interfaces
        .dump()
        .filter(lambda x: x.kind == "bond")
        .select("ifname")
))

# get the declared bundles
declared_bundles = set(map(
    lambda x: x["name"], 
    lacp_config
))

# remove all the bundles that shouldn't exist anymore
for bundle in (current_bundles - declared_bundles):
    (ndb
        .interfaces[bundle]
        .remove()
        .commit()
    )
    print(f"Removed existing LACP bundle {bundle} that is no longer present in configuration")

# create all the new bundles that don't exist yet
for bundle in (declared_bundles - current_bundles):
    (ndb
        .interfaces
        .create(
            ifname=bundle,
            kind="bond",
            bond_mode=4, # LACP
        )
        .commit()
    )
    print(f"Created new LACP bundle {bundle}")

# now process all the member interfaces
lacp_members = set()
for bundle in lacp_config:
    # grab the index for easy reference
    master_idx = ndb.interfaces[bundle["name"]]["index"]

    # remember all bundle members so they can be skipped in  
    # future layer 2 or 3 interface configurations
    lacp_members.update(bundle["members"])

    # grab all interfaces currently part of this bundle
    current_members = set(map(
        lambda x: x["ifname"], 
        ndb.interfaces
            .dump()
            .filter(lambda x: x.master == master_idx)
            .select("ifname")
        ))

    # turn the names of members supposed to be in the budle into a set
    declared_members = set(bundle["members"])

    # remove all the members that shouldn't be in the bundle anymore
    for member in (current_members - declared_members):
        (ndb
            .interfaces[bundle["name"]]
            .del_port(member)
            .commit()
        )
        print(f"Deleted member {member} from bundle {bundle['name']}")

    # add all the members that should be in the bundle but aren't yet
    members_to_add = declared_members - current_members
    if len(members_to_add):
        # however, doing so requires the bundle itself to have no master interface set
        # this will briefly interrupt traffic as it'll have to be reset
        upstream_master = ndb.interfaces[bundle["name"]]["master"]
        if upstream_master:
            (ndb
                .interfaces[upstream_master]
                .del_port(bundle["name"])
                .commit()
            )
            print(f"Temporarily removed bundle {bundle['name']} from its upstream")
        # now add all the members
        for member in members_to_add:
            # for this, the new member has to be down
            previous_state = ndb.interfaces[member]["state"]
            if previous_state != "down":
                (ndb
                    .interfaces[member]
                    .set("state", "down")
                    .commit()
                )
            # add it to the bundle
            (ndb
                .interfaces[bundle["name"]]
                .add_port(member)
                .commit()
            )
            # restore the previous state if it wasn't down
            if previous_state != "down":
                (ndb
                    .interfaces[member]
                    .set("state", previous_state)
                    .commit()
                )
            print(f"Added member {member} to bundle {bundle['name']}")
        # and restore the upstream master if needed
        if upstream_master:
            (ndb
                .interfaces[upstream_master]
                .add_port(bundle["name"])
                .commit()
            )
            print(f"Restored upstream for bundle {bundle['name']}")

# create all the virtual switches
# include a default one in case none are defined
virtual_switches = set(["default-switch"])
for interface in config["interfaces"]:
    if "virtual_switch" in interface:
        virtual_switches.add(interface["virtual_switch"])

for virtual_switch in virtual_switches:        
    if virtual_switch not in ndb.interfaces:
        (ndb
            .interfaces
            .create(
                ifname=virtual_switch,
                kind="bridge",
                br_vlan_filtering=1,
                br_vlan_default_pvid=1,
                br_vlan_stats_enabled=1,
            )
            .commit()
        )
        print(f"Created VLAN capable switch {virtual_switch}")

# configure the switchports, except for VLAN membership, which is done below
# NDB does not support VLAN filters at this time, so that step
# has to be performed via the IPRoute interface instead
for interface in config["interfaces"]:
    # force skipping LACP members
    if interface["name"] in lacp_members:
        continue

    # check if the interface is a layer 2 port
    if "vlans" in interface and len(interface["vlans"]):
        # it is, add it to the appropriate bridge if needed
        bridge_name = interface["virtual_switch"] if "virtual_switch" in interface else "default-switch"
        bridge_idx = ndb.interfaces[bridge_name]["index"]
        if ndb.interfaces[interface["name"]]["master"] != bridge_idx:
            (ndb
                .interfaces[bridge_name]
                .add_port(interface["name"])
                .commit()
            )
            print(f"Added interface {interface['name']} to bridge {bridge_name}")

    # configure the up/down state
    # default to down if not specified
    state = "up" if "enabled" in interface and interface["enabled"] else "down"
    if ndb.interfaces[interface["name"]]["state"] != state:
        (ndb
            .interfaces[interface["name"]]
            .set("state", state)
            .commit()
        )
        print(f"Set interface {interface['name']} state to {state}")

# VLAN membership of interfaces must be handled via the IPRoute module
ipr = IPRoute()

# helper function to retrieve NTLM attributes of a certain kind
# from the large list of attributes an interface might have
def _get_attribute(search_key, attrs):
    result = []
    for (key, value) in attrs:
        if search_key == key:
            result.append(value)
    return result

# function to retrieve the current VLANs on an interface
def get_vlans(ifname):
    vlans = []
    for interface in ipr.get_vlans():
        candidate_name = _get_attribute("IFLA_IFNAME", interface["attrs"])[0]
        if candidate_name == ifname:
            spec = _get_attribute("IFLA_AF_SPEC", interface["attrs"])[0]
            return _get_attribute("IFLA_BRIDGE_VLAN_INFO", spec["attrs"])


# add two tagged VLANs. flag 0 = tagged
#ip.vlan_filter("add", index=ip.link_lookup(ifname='swp3')[0], vlan_info={"vid": 888, "flags": 0})
#ip.vlan_filter("add", index=ip.link_lookup(ifname='swp3')[0], vlan_info={"vid": 989, "flags": 0})
# can check result on shell via "bridge vlan show"
# remove one of them
#ip.vlan_filter("del", index=ip.link_lookup(ifname='swp3')[0], vlan_info={"vid": 888, "flags": 0})


ndb.close()


## set VLANs
#for interface in interfaces
#    if untagged VLAN is incorrect
#        set untagged VLAN
#    for vlan in operationally set as tagged
#        if vlan not in configuration list
#            delete tagged vlan
#    for vlan in configuration list
#        if vlan not operationally set as tagged
#            add tagged vlan
#    if voice vlan exists
#        if voice vlan is incorrect
#            set voice vlan